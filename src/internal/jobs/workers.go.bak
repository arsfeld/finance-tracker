package jobs

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"time"

	"github.com/riverqueue/river"
	"github.com/jmoiron/sqlx"
	
	"finance_tracker/src/internal/models"
	provider "finance_tracker/src/providers"
)

// Dependencies that workers need
type WorkerDependencies struct {
	DB        *sqlx.DB
	Providers map[string]provider.Provider
}

// SyncTransactionsWorker handles transaction synchronization jobs
type SyncTransactionsWorker struct {
	river.WorkerDefaults[SyncTransactionsArgs]
	deps *WorkerDependencies
}

func NewSyncTransactionsWorker(deps *WorkerDependencies) *SyncTransactionsWorker {
	return &SyncTransactionsWorker{deps: deps}
}

func (w *SyncTransactionsWorker) Work(ctx context.Context, job *river.Job[SyncTransactionsArgs]) error {
	args := job.Args
	
	log.Printf("Starting transaction sync for connection %s in org %s", 
		args.ConnectionID, args.OrganizationID)

	// Get provider connection from database
	var connection models.ProviderConnection
	err := w.deps.DB.GetContext(ctx, &connection,
		`SELECT * FROM provider_connections WHERE id = $1 AND organization_id = $2`,
		args.ConnectionID, args.OrganizationID)
	if err != nil {
		return fmt.Errorf("failed to get provider connection: %w", err)
	}

	// Get provider
	provider, exists := w.deps.Providers[connection.Provider]
	if !exists {
		return fmt.Errorf("provider %s not found", connection.Provider)
	}

	// Get accounts for this connection
	var accounts []models.BankAccount
	err = w.deps.DB.SelectContext(ctx, &accounts,
		`SELECT * FROM bank_accounts WHERE provider_connection_id = $1 AND is_active = true`,
		connection.ID)
	if err != nil {
		return fmt.Errorf("failed to get accounts: %w", err)
	}

	// Determine date range
	startDate := time.Now().AddDate(0, 0, -30) // Default to 30 days
	if args.StartDate != nil {
		startDate = *args.StartDate
	}

	endDate := time.Now()
	if args.EndDate != nil {
		endDate = *args.EndDate
	}

	totalTransactions := 0
	processedAccounts := 0

	// Sync transactions for each account
	for _, account := range accounts {
		log.Printf("Syncing transactions for account %s (%s)", account.Name, account.ID)

		// Check if we should skip based on last sync (unless force sync)
		if !args.ForceSync && account.LastSync != nil {
			timeSinceLastSync := time.Since(*account.LastSync)
			if timeSinceLastSync < time.Hour {
				log.Printf("Skipping account %s - synced recently", account.Name)
				continue
			}
		}

		// Fetch transactions from provider
		transactions, err := provider.GetTransactions(ctx, connection.Credentials, account.ProviderAccountID, startDate, endDate)
		if err != nil {
			log.Printf("Warning: failed to fetch transactions for account %s: %v", account.Name, err)
			continue
		}

		// Store transactions in database
		for _, tx := range transactions {
			// Convert provider transaction to our model
			dbTx := models.Transaction{
				ID:                    tx.ID,
				OrganizationID:        args.OrganizationID,
				BankAccountID:         account.ID,
				ProviderTransactionID: tx.ProviderID,
				Amount:                tx.Amount,
				Description:           tx.Description,
				Date:                  tx.Date,
				Category:              tx.Category,
				Memo:                  tx.Memo,
				CreatedAt:             time.Now(),
				UpdatedAt:             time.Now(),
			}

			// Insert or update transaction
			_, err = w.deps.DB.NamedExecContext(ctx, `
				INSERT INTO transactions (
					id, organization_id, bank_account_id, provider_transaction_id,
					amount, description, date, category, memo, created_at, updated_at
				) VALUES (
					:id, :organization_id, :bank_account_id, :provider_transaction_id,
					:amount, :description, :date, :category, :memo, :created_at, :updated_at
				) ON CONFLICT (provider_transaction_id, bank_account_id) 
				DO UPDATE SET 
					amount = EXCLUDED.amount,
					description = EXCLUDED.description,
					category = EXCLUDED.category,
					memo = EXCLUDED.memo,
					updated_at = EXCLUDED.updated_at
			`, dbTx)
			if err != nil {
				log.Printf("Warning: failed to store transaction %s: %v", tx.ID, err)
				continue
			}
		}

		// Update account last sync time
		_, err = w.deps.DB.ExecContext(ctx,
			`UPDATE bank_accounts SET last_sync = NOW() WHERE id = $1`,
			account.ID)
		if err != nil {
			log.Printf("Warning: failed to update account last sync: %v", err)
		}

		totalTransactions += len(transactions)
		processedAccounts++
	}

	// Update connection sync status
	_, err = w.deps.DB.ExecContext(ctx,
		`UPDATE provider_connections SET 
			last_sync = NOW(), 
			sync_status = 'success', 
			error_message = NULL 
		WHERE id = $1`,
		connection.ID)
	if err != nil {
		log.Printf("Warning: failed to update connection sync status: %v", err)
	}

	log.Printf("Transaction sync completed: %d accounts processed, %d transactions synced",
		processedAccounts, totalTransactions)

	return nil
}

// SyncAccountsWorker handles account synchronization jobs
type SyncAccountsWorker struct {
	river.WorkerDefaults[SyncAccountsArgs]
	deps *WorkerDependencies
}

func NewSyncAccountsWorker(deps *WorkerDependencies) *SyncAccountsWorker {
	return &SyncAccountsWorker{deps: deps}
}

func (w *SyncAccountsWorker) Work(ctx context.Context, job *river.Job[SyncAccountsArgs]) error {
	args := job.Args
	
	log.Printf("Starting account sync for connection %s in org %s", 
		args.ConnectionID, args.OrganizationID)

	// Get provider connection
	var connection models.ProviderConnection
	err := w.deps.DB.GetContext(ctx, &connection,
		`SELECT * FROM provider_connections WHERE id = $1 AND organization_id = $2`,
		args.ConnectionID, args.OrganizationID)
	if err != nil {
		return fmt.Errorf("failed to get provider connection: %w", err)
	}

	// Get provider
	provider, exists := w.deps.Providers[connection.Provider]
	if !exists {
		return fmt.Errorf("provider %s not found", connection.Provider)
	}

	// Fetch accounts from provider
	providerAccounts, err := provider.ListAccounts(ctx, connection.Credentials)
	if err != nil {
		return fmt.Errorf("failed to fetch accounts from provider: %w", err)
	}

	syncedAccounts := 0

	// Store or update accounts in database
	for _, providerAccount := range providerAccounts {
		dbAccount := models.BankAccount{
			ID:                   providerAccount.ID,
			OrganizationID:       args.OrganizationID,
			ProviderConnectionID: connection.ID,
			ProviderAccountID:    providerAccount.ProviderID,
			Name:                 providerAccount.Name,
			Type:                 providerAccount.Type,
			Balance:              providerAccount.Balance,
			Currency:             providerAccount.Currency,
			IsActive:             true,
			CreatedAt:            time.Now(),
			UpdatedAt:            time.Now(),
		}

		// Insert or update account
		_, err = w.deps.DB.NamedExecContext(ctx, `
			INSERT INTO bank_accounts (
				id, organization_id, provider_connection_id, provider_account_id,
				name, type, balance, currency, is_active, created_at, updated_at
			) VALUES (
				:id, :organization_id, :provider_connection_id, :provider_account_id,
				:name, :type, :balance, :currency, :is_active, :created_at, :updated_at
			) ON CONFLICT (provider_account_id, provider_connection_id)
			DO UPDATE SET 
				name = EXCLUDED.name,
				type = EXCLUDED.type,
				balance = EXCLUDED.balance,
				currency = EXCLUDED.currency,
				updated_at = EXCLUDED.updated_at
		`, dbAccount)
		if err != nil {
			log.Printf("Warning: failed to store account %s: %v", providerAccount.Name, err)
			continue
		}

		syncedAccounts++
	}

	log.Printf("Account sync completed: %d accounts synced", syncedAccounts)
	return nil
}

// FullSyncWorker handles comprehensive synchronization jobs
type FullSyncWorker struct {
	river.WorkerDefaults[FullSyncArgs]
	deps *WorkerDependencies
}

func NewFullSyncWorker(deps *WorkerDependencies) *FullSyncWorker {
	return &FullSyncWorker{deps: deps}
}

func (w *FullSyncWorker) Work(ctx context.Context, job *river.Job[FullSyncArgs]) error {
	args := job.Args
	
	log.Printf("Starting full sync for connection %s in org %s", 
		args.ConnectionID, args.OrganizationID)

	// First, sync accounts
	accountsWorker := NewSyncAccountsWorker(w.deps)
	err := accountsWorker.Work(ctx, &river.Job[SyncAccountsArgs]{
		Args: SyncAccountsArgs{
			OrganizationID: args.OrganizationID,
			ConnectionID:   args.ConnectionID,
			ForceSync:      args.ForceSync,
		},
	})
	if err != nil {
		return fmt.Errorf("failed to sync accounts: %w", err)
	}

	// Then, sync transactions
	transactionsWorker := NewSyncTransactionsWorker(w.deps)
	err = transactionsWorker.Work(ctx, &river.Job[SyncTransactionsArgs]{
		Args: SyncTransactionsArgs{
			OrganizationID: args.OrganizationID,
			ConnectionID:   args.ConnectionID,
			StartDate:      args.StartDate,
			ForceSync:      args.ForceSync,
		},
	})
	if err != nil {
		return fmt.Errorf("failed to sync transactions: %w", err)
	}

	log.Printf("Full sync completed for connection %s", args.ConnectionID)
	return nil
}

// TestConnectionWorker handles connection testing jobs
type TestConnectionWorker struct {
	river.WorkerDefaults[TestConnectionArgs]
	deps *WorkerDependencies
}

func NewTestConnectionWorker(deps *WorkerDependencies) *TestConnectionWorker {
	return &TestConnectionWorker{deps: deps}
}

func (w *TestConnectionWorker) Work(ctx context.Context, job *river.Job[TestConnectionArgs]) error {
	args := job.Args
	
	log.Printf("Testing connection %s in org %s", args.ConnectionID, args.OrganizationID)

	// Get provider connection
	var connection models.ProviderConnection
	err := w.deps.DB.GetContext(ctx, &connection,
		`SELECT * FROM provider_connections WHERE id = $1 AND organization_id = $2`,
		args.ConnectionID, args.OrganizationID)
	if err != nil {
		return fmt.Errorf("failed to get provider connection: %w", err)
	}

	// Get provider
	provider, exists := w.deps.Providers[connection.Provider]
	if !exists {
		return fmt.Errorf("provider %s not found", connection.Provider)
	}

	// Test connection by listing accounts
	accounts, err := provider.ListAccounts(ctx, connection.Credentials)
	if err != nil {
		// Update connection with error
		_, updateErr := w.deps.DB.ExecContext(ctx,
			`UPDATE provider_connections SET 
				sync_status = 'error',
				error_message = $1,
				last_sync = NOW()
			WHERE id = $2`,
			err.Error(), connection.ID)
		if updateErr != nil {
			log.Printf("Warning: failed to update connection error status: %v", updateErr)
		}
		
		return fmt.Errorf("connection test failed: %w", err)
	}

	// Update connection status as healthy
	_, err = w.deps.DB.ExecContext(ctx,
		`UPDATE provider_connections SET 
			sync_status = 'success',
			error_message = NULL,
			last_sync = NOW()
		WHERE id = $1`,
		connection.ID)
	if err != nil {
		log.Printf("Warning: failed to update connection status: %v", err)
	}

	log.Printf("Connection test passed: %d accounts found", len(accounts))
	return nil
}