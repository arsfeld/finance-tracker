package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"math/rand"
	"net/http"
	"strings"
	"time"

	"github.com/rs/zerolog/log"
)

// OpenRouterRequest represents a request to the OpenRouter API
type OpenRouterRequest struct {
	Model     string    `json:"model"`
	Models    []string  `json:"models"`
	Messages  []Message `json:"messages"`
	Reasoning Reasoning `json:"reasoning"`
}

// Message represents a message in the OpenRouter API request/response
type Message struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

type Reasoning struct {
	Exclude bool `json:"exclude"`
}

// OpenRouterResponse represents a response from the OpenRouter API
type OpenRouterResponse struct {
	Id       string   `json:"id"`
	Choices  []Choice `json:"choices"`
	Error    *Error   `json:"error,omitempty"`
	Provider string   `json:"provider"`
	Model    string   `json:"model"`
	Object   string   `json:"object"`
	Created  int64    `json:"created"`
	Usage    Usage    `json:"usage"`
}

// Choice represents a choice in the OpenRouter API response
type Choice struct {
	Message            Message `json:"message"`
	FinishReason       string  `json:"finish_reason"`
	NativeFinishReason string  `json:"native_finish_reason"`
}

type Usage struct {
	PromptTokens     int `json:"prompt_tokens"`
	CompletionTokens int `json:"completion_tokens"`
	TotalTokens      int `json:"total_tokens"`
}

// Error represents an error in the OpenRouter API response
type Error struct {
	Message string `json:"message"`
	Code    int    `json:"code"`
}

// shuffleModels randomly shuffles the models slice
func shuffleModels(models []string) {
	rand.Seed(time.Now().UnixNano())
	rand.Shuffle(len(models), func(i, j int) {
		models[i], models[j] = models[j], models[i]
	})
}

// getLLMResponse sends a prompt to the OpenRouter API and returns the response
func getLLMResponse(settings *Settings, prompt string) (string, error) {
	models := strings.Split(settings.OpenRouterModel, ",")
	shuffleModels(models)

	log.Debug().Msgf("Using models: %v", models)

	reqBody := OpenRouterRequest{
		Models: models,
		Messages: []Message{
			{
				Role:    "user",
				Content: prompt,
			},
		},
		Reasoning: Reasoning{
			Exclude: true,
		},
	}

	jsonData, err := json.Marshal(reqBody)
	if err != nil {
		return "", fmt.Errorf("error marshaling request: %w", err)
	}

	req, err := http.NewRequest(http.MethodPost, settings.OpenRouterURL, bytes.NewBuffer(jsonData))
	if err != nil {
		return "", fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", settings.OpenRouterAPIKey))
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{
		Timeout: 360 * time.Second,
	}
	resp, err := client.Do(req)
	if err != nil {
		return "", fmt.Errorf("error making request: %w", err)
	}
	defer resp.Body.Close()

	// Create a comprehensive debug message
	event := log.Debug().
		Int("status_code", resp.StatusCode).
		Str("status", resp.Status).
		Interface("headers", resp.Header)

	// Read the response body for logging
	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		event.Err(err).Msg("OpenRouter response (error reading body)")
		return "", fmt.Errorf("error reading response body: %w", err)
	}
	event.Str("body", string(bodyBytes))

	// Log the comprehensive debug message
	event.Msg("OpenRouter comprehensive response")

	// Create a new reader with the body bytes for further processing
	resp.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, string(bodyBytes))
	}

	var openRouterResp OpenRouterResponse
	if err := json.NewDecoder(resp.Body).Decode(&openRouterResp); err != nil {
		return "", fmt.Errorf("error decoding response: %w", err)
	}

	log.Info().Str("model", openRouterResp.Model).Str("provider", openRouterResp.Provider).Msg(" â”” OpenRouter response")

	// Check for error in the response
	if openRouterResp.Error != nil {
		return "", fmt.Errorf("OpenRouter API error: %s (code: %d)", openRouterResp.Error.Message, openRouterResp.Error.Code)
	}

	if len(openRouterResp.Choices) == 0 {
		return "", fmt.Errorf("no response from OpenRouter")
	}

	content := openRouterResp.Choices[0].Message.Content
	if content == "" {
		return "", fmt.Errorf("received empty analysis from LLM")
	}

	// Add model information as a small note at the bottom
	content = fmt.Sprintf("%s\n\n---\n*Generated by %s*", content, openRouterResp.Model)

	return content, nil
}

// formatTransactions formats the transactions as a markdown table
func formatTransactions(transactions []Transaction) string {
	var result string
	result += "| Description | Amount | Date |\n"
	result += "|------------|---------|------|\n"

	for _, txn := range transactions {
		timestamp := txn.TransactedAt
		if timestamp == nil {
			timestamp = &txn.Posted
		}
		date := time.Unix(*timestamp, 0).Format("2006-01-02")
		result += fmt.Sprintf("| %s | %.2f | %s |\n", txn.Description, txn.Amount, date)
	}

	return result
}

// formatAccounts formats the accounts as a markdown table
func formatAccounts(accounts []Account) string {
	var result string
	result += "| Account | Balance | Last Synced |\n"
	result += "|------------|---------|------|\n"

	for _, account := range accounts {
		result += fmt.Sprintf("| %s | %.2f | %s |\n", account.Name, account.Balance, time.Unix(account.BalanceDate, 0).Format("2006-01-02"))
	}

	return result
}

// generateAnalysisPrompt generates a prompt for the AI to analyze transactions
func generateAnalysisPrompt(accounts []Account, transactions []Transaction, startDate, endDate time.Time) string {
	transactionsFormatted := formatTransactions(transactions)
	accountsFormatted := formatAccounts(accounts)
	return fmt.Sprintf(`## Financial Transaction Analysis
Billing Period: %s to %s

I need a structured analysis of the provided financial transactions. Please create a concise report (max 150 words total) with the following sections:

### Summary
Provide a human-friendly overview of spending patterns during this period. Be specific about trends and notable observations.

### Analysis Breakdown
1. **Total Expenses**: ${{total}} (Sum of all purchases, excluding payments, credits, and refunds)
2. **Major Categories**: List the top 4-5 spending categories with their totals
   - Category 1: ${{amount}}
   - Category 2: ${{amount}}
   - ...
3. **Largest Expenses**: 
   - ${{expense 1}}: ${{amount}} at ${{merchant}} on ${{date}}
   - ${{expense 2}}: ${{amount}} at ${{merchant}} on ${{date}}
   - ${{expense 3}}: ${{amount}} at ${{merchant}} on ${{date}}
4. **Account Status**:
   - ${{account name}}: Balance ${{amount}}, Last synced ${{date}}
   - ...

Notes:
- Consider only outgoing expenses in your analysis (ignore incoming payments, credits, refunds)
- Format all monetary values consistently (e.g., $1,234.56)
- If a category has no transactions, indicate 'No spending in this category'

Accounts Information: 
%s

Transactions: 
%s`, startDate.Format("2006-01-02"), endDate.Format("2006-01-02"), accountsFormatted, transactionsFormatted)
}
