package handlers

import (
	"encoding/json"
	"net/http"
	"strconv"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/google/uuid"
	"finance_tracker/src/internal/models"
	"finance_tracker/src/internal/services"
)

type JobHandler struct {
	jobService    *services.JobService
	workerService *services.WorkerService
	syncService   *services.SyncService
}

func NewJobHandler(jobService *services.JobService, workerService *services.WorkerService, syncService *services.SyncService) *JobHandler {
	return &JobHandler{
		jobService:    jobService,
		workerService: workerService,
		syncService:   syncService,
	}
}

// ListJobs handles GET /api/v1/jobs
func (h *JobHandler) ListJobs(w http.ResponseWriter, r *http.Request) {
	organizationID := GetOrganizationID(r)
	if organizationID == uuid.Nil {
		http.Error(w, "Organization ID required", http.StatusBadRequest)
		return
	}

	// Parse query parameters
	filters := models.JobFilters{
		OrganizationID: &organizationID,
		Limit:          50, // Default limit
	}

	// Parse status filter
	if statusStr := r.URL.Query().Get("status"); statusStr != "" {
		status := models.JobStatus(statusStr)
		filters.Status = []models.JobStatus{status}
	}

	// Parse type filter
	if typeStr := r.URL.Query().Get("type"); typeStr != "" {
		jobType := models.JobType(typeStr)
		filters.Type = []models.JobType{jobType}
	}

	// Parse limit
	if limitStr := r.URL.Query().Get("limit"); limitStr != "" {
		if limit, err := strconv.Atoi(limitStr); err == nil && limit > 0 && limit <= 100 {
			filters.Limit = limit
		}
	}

	// Parse offset
	if offsetStr := r.URL.Query().Get("offset"); offsetStr != "" {
		if offset, err := strconv.Atoi(offsetStr); err == nil && offset >= 0 {
			filters.Offset = offset
		}
	}

	// Parse connection filter
	if connStr := r.URL.Query().Get("connection_id"); connStr != "" {
		if connID, err := uuid.Parse(connStr); err == nil {
			filters.ProviderConnectionID = &connID
		}
	}

	jobs, err := h.jobService.ListJobs(r.Context(), filters)
	if err != nil {
		http.Error(w, "Failed to list jobs", http.StatusInternalServerError)
		return
	}

	writeJSON(w, map[string]interface{}{
		"jobs": jobs,
	})
}

// GetJob handles GET /api/v1/jobs/{id}
func (h *JobHandler) GetJob(w http.ResponseWriter, r *http.Request) {
	organizationID := GetOrganizationID(r)
	if organizationID == uuid.Nil {
		http.Error(w, "Organization ID required", http.StatusBadRequest)
		return
	}

	jobIDStr := chi.URLParam(r, "id")
	jobID, err := uuid.Parse(jobIDStr)
	if err != nil {
		http.Error(w, "Invalid job ID", http.StatusBadRequest)
		return
	}

	job, err := h.jobService.GetJob(r.Context(), jobID)
	if err != nil {
		http.Error(w, "Job not found", http.StatusNotFound)
		return
	}

	// Verify job belongs to organization
	if job.OrganizationID != organizationID {
		http.Error(w, "Job not found", http.StatusNotFound)
		return
	}

	writeJSON(w, job)
}

// CreateSyncJob handles POST /api/v1/connections/{id}/sync
func (h *JobHandler) CreateSyncJob(w http.ResponseWriter, r *http.Request) {
	organizationID := GetOrganizationID(r)
	if organizationID == uuid.Nil {
		http.Error(w, "Organization ID required", http.StatusBadRequest)
		return
	}

	connectionIDStr := chi.URLParam(r, "id")
	connectionID, err := uuid.Parse(connectionIDStr)
	if err != nil {
		http.Error(w, "Invalid connection ID", http.StatusBadRequest)
		return
	}

	var req struct {
		Type          string     `json:"type"`          // "full", "transactions", "accounts", "test"
		StartDate     *time.Time `json:"start_date"`
		EndDate       *time.Time `json:"end_date"`
		ForceSync     bool       `json:"force_sync"`
		IncludeHistory bool      `json:"include_history"`
		Priority      string     `json:"priority"`      // "low", "normal", "high", "urgent"
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	// Default values
	if req.Type == "" {
		req.Type = "transactions"
	}
	if req.Priority == "" {
		req.Priority = "normal"
	}

	var job *models.Job

	switch req.Type {
	case "full":
		job, err = h.syncService.CreateFullSyncJob(r.Context(), organizationID, connectionID, req.IncludeHistory, req.StartDate)
	case "transactions":
		job, err = h.syncService.CreateTransactionSyncJob(r.Context(), organizationID, connectionID, req.StartDate, req.EndDate, req.ForceSync)
	case "accounts":
		params := models.SyncAccountsParams{ForceSync: req.ForceSync}
		job, err = h.syncService.CreateSyncJob(r.Context(), organizationID, connectionID, models.JobTypeSyncAccounts, params)
	case "test":
		params := models.TestConnectionParams{ValidateAccounts: true}
		job, err = h.syncService.CreateSyncJob(r.Context(), organizationID, connectionID, models.JobTypeTestConnection, params)
	default:
		http.Error(w, "Invalid sync type", http.StatusBadRequest)
		return
	}

	if err != nil {
		http.Error(w, "Failed to create sync job", http.StatusInternalServerError)
		return
	}

	// Update priority if specified
	if req.Priority != "normal" {
		priority := models.JobPriority(req.Priority)
		err = h.jobService.UpdateJob(r.Context(), job.ID, models.UpdateJobParams{
			Priority: &priority,
		})
		if err != nil {
			// Log warning but don't fail the request
			// log.Printf("Warning: failed to update job priority: %v", err)
		}
	}

	w.WriteHeader(http.StatusCreated)
	writeJSON(w, job)
}

// CancelJob handles POST /api/v1/jobs/{id}/cancel
func (h *JobHandler) CancelJob(w http.ResponseWriter, r *http.Request) {
	organizationID := GetOrganizationID(r)
	if organizationID == uuid.Nil {
		http.Error(w, "Organization ID required", http.StatusBadRequest)
		return
	}

	jobIDStr := chi.URLParam(r, "id")
	jobID, err := uuid.Parse(jobIDStr)
	if err != nil {
		http.Error(w, "Invalid job ID", http.StatusBadRequest)
		return
	}

	// Verify job belongs to organization
	job, err := h.jobService.GetJob(r.Context(), jobID)
	if err != nil {
		http.Error(w, "Job not found", http.StatusNotFound)
		return
	}

	if job.OrganizationID != organizationID {
		http.Error(w, "Job not found", http.StatusNotFound)
		return
	}

	err = h.jobService.CancelJob(r.Context(), jobID)
	if err != nil {
		http.Error(w, "Failed to cancel job", http.StatusInternalServerError)
		return
	}

	writeJSON(w, map[string]string{"status": "cancelled"})
}

// PauseJob handles POST /api/v1/jobs/{id}/pause
func (h *JobHandler) PauseJob(w http.ResponseWriter, r *http.Request) {
	organizationID := GetOrganizationID(r)
	if organizationID == uuid.Nil {
		http.Error(w, "Organization ID required", http.StatusBadRequest)
		return
	}

	jobIDStr := chi.URLParam(r, "id")
	jobID, err := uuid.Parse(jobIDStr)
	if err != nil {
		http.Error(w, "Invalid job ID", http.StatusBadRequest)
		return
	}

	// Verify job belongs to organization
	job, err := h.jobService.GetJob(r.Context(), jobID)
	if err != nil {
		http.Error(w, "Job not found", http.StatusNotFound)
		return
	}

	if job.OrganizationID != organizationID {
		http.Error(w, "Job not found", http.StatusNotFound)
		return
	}

	err = h.jobService.PauseJob(r.Context(), jobID)
	if err != nil {
		http.Error(w, "Failed to pause job", http.StatusInternalServerError)
		return
	}

	writeJSON(w, map[string]string{"status": "paused"})
}

// ResumeJob handles POST /api/v1/jobs/{id}/resume
func (h *JobHandler) ResumeJob(w http.ResponseWriter, r *http.Request) {
	organizationID := GetOrganizationID(r)
	if organizationID == uuid.Nil {
		http.Error(w, "Organization ID required", http.StatusBadRequest)
		return
	}

	jobIDStr := chi.URLParam(r, "id")
	jobID, err := uuid.Parse(jobIDStr)
	if err != nil {
		http.Error(w, "Invalid job ID", http.StatusBadRequest)
		return
	}

	// Verify job belongs to organization
	job, err := h.jobService.GetJob(r.Context(), jobID)
	if err != nil {
		http.Error(w, "Job not found", http.StatusNotFound)
		return
	}

	if job.OrganizationID != organizationID {
		http.Error(w, "Job not found", http.StatusNotFound)
		return
	}

	err = h.jobService.ResumeJob(r.Context(), jobID)
	if err != nil {
		http.Error(w, "Failed to resume job", http.StatusInternalServerError)
		return
	}

	writeJSON(w, map[string]string{"status": "pending"})
}

// RetryJob handles POST /api/v1/jobs/{id}/retry
func (h *JobHandler) RetryJob(w http.ResponseWriter, r *http.Request) {
	organizationID := GetOrganizationID(r)
	if organizationID == uuid.Nil {
		http.Error(w, "Organization ID required", http.StatusBadRequest)
		return
	}

	jobIDStr := chi.URLParam(r, "id")
	jobID, err := uuid.Parse(jobIDStr)
	if err != nil {
		http.Error(w, "Invalid job ID", http.StatusBadRequest)
		return
	}

	// Verify job belongs to organization
	job, err := h.jobService.GetJob(r.Context(), jobID)
	if err != nil {
		http.Error(w, "Job not found", http.StatusNotFound)
		return
	}

	if job.OrganizationID != organizationID {
		http.Error(w, "Job not found", http.StatusNotFound)
		return
	}

	newJob, err := h.jobService.RetryJob(r.Context(), jobID)
	if err != nil {
		http.Error(w, "Failed to retry job", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusCreated)
	writeJSON(w, newJob)
}

// GetJobStats handles GET /api/v1/jobs/stats
func (h *JobHandler) GetJobStats(w http.ResponseWriter, r *http.Request) {
	organizationID := GetOrganizationID(r)
	if organizationID == uuid.Nil {
		http.Error(w, "Organization ID required", http.StatusBadRequest)
		return
	}

	// Default to last 7 days
	since := time.Now().AddDate(0, 0, -7)
	if sinceStr := r.URL.Query().Get("since"); sinceStr != "" {
		if parsedSince, err := time.Parse(time.RFC3339, sinceStr); err == nil {
			since = parsedSince
		}
	}

	stats, err := h.jobService.GetJobStats(r.Context(), organizationID, since)
	if err != nil {
		http.Error(w, "Failed to get job stats", http.StatusInternalServerError)
		return
	}

	writeJSON(w, stats)
}

// GetWorkerStats handles GET /api/v1/workers/stats
func (h *JobHandler) GetWorkerStats(w http.ResponseWriter, r *http.Request) {
	stats, err := h.workerService.GetWorkerStats(r.Context())
	if err != nil {
		http.Error(w, "Failed to get worker stats", http.StatusInternalServerError)
		return
	}

	writeJSON(w, stats)
}

// ListWorkers handles GET /api/v1/workers
func (h *JobHandler) ListWorkers(w http.ResponseWriter, r *http.Request) {
	workers, err := h.workerService.ListWorkers(r.Context())
	if err != nil {
		http.Error(w, "Failed to list workers", http.StatusInternalServerError)
		return
	}

	writeJSON(w, map[string]interface{}{
		"workers": workers,
	})
}

// writeJSON is a helper function to write JSON response
func writeJSON(w http.ResponseWriter, data interface{}) {
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(data)
}