package handlers

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/google/uuid"
	
	"finance_tracker/src/internal/jobs"
)

type RiverJobHandler struct {
	jobClient *jobs.SimpleJobClient
}

func NewRiverJobHandler(jobClient *jobs.SimpleJobClient) *RiverJobHandler {
	return &RiverJobHandler{
		jobClient: jobClient,
	}
}

// CreateSyncJob handles POST /api/v1/connections/{id}/sync
func (h *RiverJobHandler) CreateSyncJob(w http.ResponseWriter, r *http.Request) {
	organizationID := GetOrganizationID(r)
	if organizationID == uuid.Nil {
		http.Error(w, "Organization ID required", http.StatusBadRequest)
		return
	}

	connectionIDStr := chi.URLParam(r, "id")
	connectionID, err := uuid.Parse(connectionIDStr)
	if err != nil {
		http.Error(w, "Invalid connection ID", http.StatusBadRequest)
		return
	}

	var req struct {
		Type          string     `json:"type"`          // "full", "transactions", "accounts", "test"
		StartDate     *time.Time `json:"start_date"`
		EndDate       *time.Time `json:"end_date"`
		ForceSync     bool       `json:"force_sync"`
		IncludeHistory bool      `json:"include_history"`
		Priority      string     `json:"priority"`      // "low", "normal", "high", "urgent"
		ScheduledAt   *time.Time `json:"scheduled_at"`  // Optional scheduling
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	// Default values
	if req.Type == "" {
		req.Type = "transactions"
	}

	// Set priority
	priority := jobs.PriorityNormal
	switch req.Priority {
	case "low":
		priority = jobs.PriorityLow
	case "high":
		priority = jobs.PriorityHigh
	case "urgent":
		priority = jobs.PriorityUrgent
	}

	// Prepare insert options
	insertOpts := river.InsertOpts{
		Priority: priority,
		Queue:    river.QueueDefault,
	}

	if req.ScheduledAt != nil {
		insertOpts.ScheduledAt = *req.ScheduledAt
	}

	// Create appropriate job based on type
	var job *river.JobRow
	
	switch req.Type {
	case "full":
		job, err = h.jobClient.InsertFullSyncJob(r.Context(), jobs.FullSyncArgs{
			OrganizationID: organizationID,
			ConnectionID:   connectionID,
			StartDate:      req.StartDate,
			IncludeHistory: req.IncludeHistory,
			ForceSync:      req.ForceSync,
		}, insertOpts)
		
	case "transactions":
		job, err = h.jobClient.InsertSyncTransactionsJob(r.Context(), jobs.SyncTransactionsArgs{
			OrganizationID: organizationID,
			ConnectionID:   connectionID,
			StartDate:      req.StartDate,
			EndDate:        req.EndDate,
			ForceSync:      req.ForceSync,
		}, insertOpts)
		
	case "accounts":
		job, err = h.jobClient.InsertSyncAccountsJob(r.Context(), jobs.SyncAccountsArgs{
			OrganizationID: organizationID,
			ConnectionID:   connectionID,
			ForceSync:      req.ForceSync,
		}, insertOpts)
		
	case "test":
		job, err = h.jobClient.InsertTestConnectionJob(r.Context(), jobs.TestConnectionArgs{
			OrganizationID:   organizationID,
			ConnectionID:     connectionID,
			ValidateAccounts: true,
		}, insertOpts)
		
	default:
		http.Error(w, "Invalid sync type", http.StatusBadRequest)
		return
	}

	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to create sync job: %v", err), http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusCreated)
	writeJSON(w, map[string]interface{}{
		"id":           job.ID,
		"kind":         job.Kind,
		"state":        job.State,
		"priority":     job.Priority,
		"created_at":   job.CreatedAt,
		"scheduled_at": job.ScheduledAt,
		"metadata":     job.Metadata,
	})
}

// ListJobs handles GET /api/v1/jobs
func (h *RiverJobHandler) ListJobs(w http.ResponseWriter, r *http.Request) {
	organizationID := GetOrganizationID(r)
	if organizationID == uuid.Nil {
		http.Error(w, "Organization ID required", http.StatusBadRequest)
		return
	}

	// Parse query parameters
	limit := 50 // Default limit
	offset := 0 // Default offset

	if limitStr := r.URL.Query().Get("limit"); limitStr != "" {
		if parsedLimit, err := strconv.Atoi(limitStr); err == nil && parsedLimit > 0 && parsedLimit <= 100 {
			limit = parsedLimit
		}
	}

	if offsetStr := r.URL.Query().Get("offset"); offsetStr != "" {
		if parsedOffset, err := strconv.Atoi(offsetStr); err == nil && parsedOffset >= 0 {
			offset = parsedOffset
		}
	}

	jobs, err := h.jobClient.ListJobsForOrganization(r.Context(), organizationID, limit, offset)
	if err != nil {
		http.Error(w, "Failed to list jobs", http.StatusInternalServerError)
		return
	}

	// Convert River jobs to our API format
	apiJobs := make([]map[string]interface{}, len(jobs))
	for i, job := range jobs {
		progressCurrent := 0
		progressTotal := 100
		
		// Extract progress from metadata if available
		if job.Metadata != nil {
			if current, ok := job.Metadata["progress_current"].(float64); ok {
				progressCurrent = int(current)
			}
			if total, ok := job.Metadata["progress_total"].(float64); ok {
				progressTotal = int(total)
			}
		}

		apiJobs[i] = map[string]interface{}{
			"id":               job.ID,
			"type":             job.Kind,
			"status":           string(job.State),
			"title":            fmt.Sprintf("%s job", job.Kind),
			"progress_current": progressCurrent,
			"progress_total":   progressTotal,
			"created_at":       job.CreatedAt,
			"scheduled_at":     job.ScheduledAt,
			"started_at":       job.AttemptedAt,
			"completed_at":     job.FinalizedAt,
			"attempt":          job.Attempt,
			"max_attempts":     job.MaxAttempts,
			"errors":           job.Errors,
			"metadata":         job.Metadata,
		}
	}

	writeJSON(w, map[string]interface{}{
		"jobs": apiJobs,
	})
}

// GetJob handles GET /api/v1/jobs/{id}
func (h *RiverJobHandler) GetJob(w http.ResponseWriter, r *http.Request) {
	organizationID := GetOrganizationID(r)
	if organizationID == uuid.Nil {
		http.Error(w, "Organization ID required", http.StatusBadRequest)
		return
	}

	jobIDStr := chi.URLParam(r, "id")
	jobID, err := strconv.ParseInt(jobIDStr, 10, 64)
	if err != nil {
		http.Error(w, "Invalid job ID", http.StatusBadRequest)
		return
	}

	job, err := h.jobClient.GetJob(r.Context(), jobID)
	if err != nil {
		http.Error(w, "Job not found", http.StatusNotFound)
		return
	}

	// TODO: Verify job belongs to organization (would need to join with river_job_states)

	progressCurrent := 0
	progressTotal := 100
	
	if job.Metadata != nil {
		if current, ok := job.Metadata["progress_current"].(float64); ok {
			progressCurrent = int(current)
		}
		if total, ok := job.Metadata["progress_total"].(float64); ok {
			progressTotal = int(total)
		}
	}

	writeJSON(w, map[string]interface{}{
		"id":               job.ID,
		"type":             job.Kind,
		"status":           string(job.State),
		"title":            fmt.Sprintf("%s job", job.Kind),
		"progress_current": progressCurrent,
		"progress_total":   progressTotal,
		"created_at":       job.CreatedAt,
		"scheduled_at":     job.ScheduledAt,
		"started_at":       job.AttemptedAt,
		"completed_at":     job.FinalizedAt,
		"attempt":          job.Attempt,
		"max_attempts":     job.MaxAttempts,
		"errors":           job.Errors,
		"metadata":         job.Metadata,
	})
}

// CancelJob handles POST /api/v1/jobs/{id}/cancel
func (h *RiverJobHandler) CancelJob(w http.ResponseWriter, r *http.Request) {
	organizationID := GetOrganizationID(r)
	if organizationID == uuid.Nil {
		http.Error(w, "Organization ID required", http.StatusBadRequest)
		return
	}

	jobIDStr := chi.URLParam(r, "id")
	jobID, err := strconv.ParseInt(jobIDStr, 10, 64)
	if err != nil {
		http.Error(w, "Invalid job ID", http.StatusBadRequest)
		return
	}

	// TODO: Verify job belongs to organization

	err = h.jobClient.CancelJob(r.Context(), jobID)
	if err != nil {
		http.Error(w, "Failed to cancel job", http.StatusInternalServerError)
		return
	}

	writeJSON(w, map[string]string{"status": "cancelled"})
}

// GetJobStats handles GET /api/v1/jobs/stats
func (h *RiverJobHandler) GetJobStats(w http.ResponseWriter, r *http.Request) {
	organizationID := GetOrganizationID(r)
	if organizationID == uuid.Nil {
		http.Error(w, "Organization ID required", http.StatusBadRequest)
		return
	}

	// Default to last 7 days
	since := time.Now().AddDate(0, 0, -7)
	if sinceStr := r.URL.Query().Get("since"); sinceStr != "" {
		if parsedSince, err := time.Parse(time.RFC3339, sinceStr); err == nil {
			since = parsedSince
		}
	}

	stats, err := h.jobClient.GetJobStatsForOrganization(r.Context(), organizationID, since)
	if err != nil {
		http.Error(w, "Failed to get job stats", http.StatusInternalServerError)
		return
	}

	writeJSON(w, stats)
}

// GetWorkerStats handles GET /api/v1/workers/stats
func (h *RiverJobHandler) GetWorkerStats(w http.ResponseWriter, r *http.Request) {
	// For River, worker stats would come from River's internal tables
	// This is a simplified version
	stats := map[string]interface{}{
		"total_workers":       1, // Would query River's internal state
		"total_jobs":          0,
		"total_capacity":      10,
		"utilization_percent": 0.0,
		"by_status": map[string]interface{}{
			"active": map[string]interface{}{
				"count":    1,
				"jobs":     0,
				"capacity": 10,
			},
		},
	}

	writeJSON(w, stats)
}

// ListWorkers handles GET /api/v1/workers
func (h *RiverJobHandler) ListWorkers(w http.ResponseWriter, r *http.Request) {
	// For River, this would query River's internal worker state
	// This is a simplified version
	workers := []map[string]interface{}{
		{
			"id":                 "river-worker-1",
			"hostname":           "localhost",
			"status":             "active",
			"max_concurrent_jobs": 10,
			"current_job_count":   0,
			"last_heartbeat":      time.Now(),
		},
	}

	writeJSON(w, map[string]interface{}{
		"workers": workers,
	})
}